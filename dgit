#!/usr/bin/bash

DGIT_DIR=".dgit"
DGIT_META_FILE=".dgit_meta"
DGIT_META_COMMIT="git_commit"
DGIT_META_TIMESTAMP="timestamp"
DGIT_META_LOG_NAME="log_name"
DGIT_META_BASH_NAME="bash_name"
DGIT_COMMAND_FILE="dgit_command.sh"
DGIT_OUTPUT_DIR="output"
DGIT_STDOUT_FILE="dgit_stdout.log"

function dgit_init() {
    if [ ! -d ".git" ]; then
        echo "Please first initialize git repository"
        exit 1
    fi
    if [ -d "$DGIT_DIR" ]; then
        echo "dgit already initialized"
        exit 1
    fi
    mkdir $DGIT_DIR
    echo "$DGIT_DIR/" >> .gitignore
    echo "Initialize empty dgit repository in $(pwd)/$DGIT_DIR/"
}

function _dgit_check_init() {
    if [ ! -d "$DGIT_DIR" ]; then
        echo "Please first initialize dgit"
        exit 1
    fi
}

function dgit_log() {
    function dgit_log_print_help_and_exit() {
        echo "Usage: dgit log [--name <log_name>] [bash_file]"
        exit 1
    }

    # Check if dgit is initialized
    _dgit_check_init

    # Get the log dir name
    timestamp=$(date +%s)
    log_name="anonymous"
    if [ "$2" == "--name" ]; then
        if [ -z "$3" ]; then
            dgit_log_print_help_and_exit
        fi
        if [[ ! $3 =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
            echo "Log name must be a valid bash variable name"
            exit 1
        fi
        log_name="$3"
        shift 2
    fi
    log_dir="$DGIT_DIR/${timestamp}_$log_name"

    # Check if the bash file exists
    bash_file=$2
    function check_file() {
        if [[ ! $1 == *.sh ]]; then
            echo "You must provide a bash file ending with .sh"
            exit 1
        fi
        if [ ! -f $1 ]; then
            echo "File $1 does not exist"
            exit 1
        fi
    }
    check_file $bash_file

    # Record the git head
    git_head=$(git rev-parse HEAD)
    if [[ ! $git_head =~ ^[a-z0-9]+$ ]]; then
        echo "Failed to get git head"
        echo "Have you made your first commit?"
        exit 1
    fi
    if [ $(git status --porcelain | wc -l) -ne 0 ]; then
        git add . > /dev/null
        git commit -m "dgit auto commit for logging" > /dev/null
        git_head=$(git rev-parse HEAD)
        git reset HEAD~1 > /dev/null
    fi

    # Create the log dir
    mkdir $log_dir
    if [ ! -d $log_dir ]; then
        echo "Failed to create log directory: $log_dir"
        exit 1
    fi
    cp $bash_file $log_dir/$DGIT_COMMAND_FILE
    meta_file="$log_dir/$DGIT_META_FILE"
    echo "$DGIT_META_COMMIT: $git_head" > $meta_file
    echo "$DGIT_META_TIMESTAMP: $timestamp" >> $meta_file
    echo "$DGIT_META_LOG_NAME: $log_name" >> $meta_file
    echo "$DGIT_META_BASH_NAME: $bash_file" >> $meta_file

    # Register the interrupt handler
    ready_to_exit=0
    function interrupt_handler() {
        if [ $ready_to_exit -eq 1 ]; then
            kill -9 $bash_pid
        fi
    }
    trap interrupt_handler SIGINT

    # Start the strace
    strace_file="$log_dir/dgit_strace.log"
    strace -f -y -s 65535 -e write -o $strace_file bash $bash_file &
    strace_pid=$! 
    while [ -z "$bash_pid" ] && kill -0 $strace_pid; do
        bash_pid=$(ps -ef | grep -E ".* $strace_pid .* bash $bash_file" | grep -v grep | awk '{print $2}' | grep -v $strace_pid)
    done

    # Monitor the strace output
    echo "output_files:" >> $meta_file
    mkdir -p $log_dir/$DGIT_OUTPUT_DIR
    function strace_monitor() {
        tail -n +1 --pid=$strace_pid -F $strace_file 2> /dev/null | while read -r line; do
            if [[ $line == [0-9]*write* ]]; then
                file=$(echo $line | grep -m 1 -oE "<[^>]*>" | sed -E "s/[<>]//g")
                content=$(echo $line | sed "s/^[^\"]*\"\(.*\)\"[^\"]*$/\1/")
                if [ -z "$file" ]; then
                    continue
                fi
                if [ -z "$content" ]; then
                    continue
                fi
                if [[ $file == "/dev/pts"* ]]; then
                    printf "$content" >> $log_dir/$DGIT_OUTPUT_DIR/$DGIT_STDOUT_FILE
                elif [[ $file == $(pwd)* ]]; then
                    if [ -z $(echo "$output_files" | grep -F "$file") ]; then
                        output_files="$output_files"$'\n'"$file"
                        echo $file >> $meta_file
                    fi
                fi
            fi
        done
    }
    strace_monitor &
    monitor_pid=$! 
    while [ -z "$monitor_tail_pid" ] && kill -0 $monitor_pid; do
        monitor_tail_pid=$(ps -ef | grep -E ".* $monitor_pid .* tail.*" | grep -v grep | awk '{print $2}')
    done

    # Wait for the strace to finish
    ready_to_exit=1
    wait $strace_pid
    wait $monitor_pid
    trap - SIGINT

    # Parse the strace log
    echo -e "\n\033[0;32mparsing strace log ...\033[0m"
    for file in $(cat "$log_dir/$DGIT_META_FILE" | grep -v ":"); do
        new_file=$(echo $file | sed "s|$(pwd)|$log_dir/$DGIT_OUTPUT_DIR|")
        mkdir -p $(dirname $new_file)
        cp --reflink=auto $file $new_file
        chmod 444 $new_file
    done
    echo -e "\033[0;32mparsing strace log done\033[0m"
}

function _dgit_get_meta() {
    meta_file="$DGIT_DIR/$1/$DGIT_META_FILE"
    meta_item=DGIT_META_$2
    echo "$(cat $meta_file | grep "${!meta_item}" | sed "s/${!meta_item}: //")"
}

function dgit_ls() {
    _dgit_check_init
    echo "-------------------------------------------------------------------------------------"
    echo -e "Timestamp\t\t| Log Name\t| Commit\t| Bash File"
    echo "-------------------------------------------------------------------------------------"
    for log_dir in $(ls -1 $DGIT_DIR/); do
        timestamp=$(_dgit_get_meta $log_dir TIMESTAMP)
        timestamp=$(date -d @$timestamp +"%Y-%m-%d %H:%M:%S")
        log_name=$(_dgit_get_meta $log_dir LOG_NAME)
        commit_hash=$(_dgit_get_meta $log_dir COMMIT | head -c 8)
        bash_file=$(_dgit_get_meta $log_dir BASH_NAME)
        bash_command=$(cat "$DGIT_DIR/$log_dir/$DGIT_COMMAND_FILE" | head -n 1)
        echo -e "$timestamp\t| $log_name\t| $commit_hash\t| $bash_file: $bash_command (...)"
    done
    echo "-------------------------------------------------------------------------------------"
}

function _dgit_get_log_dir() {
    log_dir=$(ls -1 --color=never $DGIT_DIR/ | grep -E "^[0-9]+_$1$" | sort -r | head -n 1)
    echo $log_dir
}

function _dgit_get_log_dir_or_exit() {
    log_dir=$(_dgit_get_log_dir $1)
    if [ -z "$log_dir" ]; then
        echo "Log name $1 not found"
        exit 1
    fi
    echo $log_dir
}

function dgit_stdout() {
    _dgit_check_init
    if [ -z "$2" ]; then
        echo "Usage: dgit stdout <log_name>"
        exit 1
    fi
    log_dir=$(_dgit_get_log_dir_or_exit $2)
    cat "$DGIT_DIR/$log_dir/$DGIT_OUTPUT_DIR/$DGIT_STDOUT_FILE"
}

function dgit_fout() {
    _dgit_check_init
    prompt=-i
    if [ "$2" == "-f" ]; then
        prompt=
        shift
    fi
    if [ -z "$2" ]; then
        echo "Usage: dgit fout [-f] <log_name>"
        exit 1
    fi
    log_dir=$(_dgit_get_log_dir_or_exit $2)
    for file in $(cat "$DGIT_DIR/$log_dir/$DGIT_META_FILE" | grep -v ":"); do
        stored_file=$(echo $file | sed "s|$(pwd)|$DGIT_DIR/$log_dir/$DGIT_OUTPUT_DIR|")
        cp $prompt --reflink=auto $stored_file $file
    done
}

function dgit_checkout() {
    _dgit_check_init
    if [ -z "$2" ]; then
        echo "Usage: dgit checkout <log_name>"
        exit 1
    fi
    log_dir=$(_dgit_get_log_dir_or_exit $2)
    commit_hash=$(_dgit_get_meta $log_dir COMMIT)
    if [ -z "$commit_hash" ]; then
        echo "Failed to find commit hash"
        exit 1
    fi
    git checkout $commit_hash
    if [ $? -ne 0 ]; then
        echo "Failed to checkout commit $commit_hash"
        exit 1
    fi
    timestamp=$(_dgit_get_meta $log_dir TIMESTAMP)
    timestamp=$(date -d @$timestamp +"%Y-%m-%d %H:%M:%S")
    echo "Checkout log $2 at $timestamp"
}

function dgit_print_help_and_exit() {
    echo "Usage: dgit init|log|ls|stdout|fout|checkout"
    exit 1
}

if [ "$#" -eq 0 ]; then
    dgit_print_help_and_exit
fi

if [ "$1" == "init" ]; then
    dgit_init
elif [ "$1" == "log" ]; then
    dgit_log "$@"
elif [ "$1" == "ls" ]; then
    dgit_ls
elif [ "$1" == "stdout" ]; then
    dgit_stdout "$@"
elif [ "$1" == "fout" ]; then
    dgit_fout "$@"
elif [ "$1" == "checkout" ]; then
    dgit_checkout "$@"
else
    dgit_print_help_and_exit
fi
